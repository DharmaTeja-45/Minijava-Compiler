//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import visitor.Pass1.funcAttr;

import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class liveanalysis<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   Integer line_counter= 1;
   Integer arg= 0;
   blockinfo current_block= new blockinfo(1);
   functioninfo current_function= new functioninfo("main");
   public Map<String, functioninfo> function_map= new HashMap<String, functioninfo>();
   ArrayList <String> registers= new ArrayList<String>(Arrays.asList("s0","s1","s2","s3","s4","s5","s6","s7","t0","t1","t2","t3","t4","t5","t6","t7","t8","t9"));
   Integer free_reg= 18;
   Map<String, Integer> label_linemap= new HashMap<String, Integer>();
   boolean label_status= false;
   Integer argcounter= 0;



   public void calculate_jumps(){
      for(blockinfo b: current_function.blocks){
         if(b.jump_block_name.equals("")== false){
            b.next_block= label_linemap.get(b.jump_block_name);
         }
      }
   }

   public void calculate_inout(){
      boolean changed= true;
      while(changed){
         changed= false;
         for(int i= current_function.blocks.size()-1; i>=0; i--){
            blockinfo b= current_function.blocks.get(i);
            Set<String> old_in= new HashSet<String>(b.in);
            Set<String> old_out= new HashSet<String>(b.out);

            //calculate out set
            b.out.clear();
            if(b.next_block != -1){
               blockinfo next_b= null;
               for(blockinfo bb: current_function.blocks){
                  if(bb.line_number.equals(b.next_block)){
                     next_b= bb;
                     break;
                  }
               }
               b.out.addAll(next_b.in);
            }
            if(b.jump_block != -1){
               blockinfo jump_b= null;
               for(blockinfo bb: current_function.blocks){
                  if(bb.line_number.equals(b.jump_block)){
                     jump_b= bb;
                     break;
                  }
               }
               b.out.addAll(jump_b.in);
            }

            //calculate in set
            b.in.clear();
            b.in.addAll(b.use);
            Set<String> out_minus_def= new HashSet<String>(b.out);
            out_minus_def.removeAll(b.def);
            b.in.addAll(out_minus_def);

            if(!b.in.equals(old_in) || !b.out.equals(old_out)){
               changed= true;
            }
         }
      }
   }

   public void calculate_liverange(functioninfo func){
      for(blockinfo b: func.blocks){
         Integer block_line= b.line_number;
         for(String var: b.in){
            intervalinfo interval= func.interval_map.get(var);
            if(interval== null){
               interval= new intervalinfo(var, block_line, block_line);
               func.interval_map.put(var, interval);
            }
            else{
               interval.start_line= Math.min(interval.start_line, block_line);
               interval.end_line= Math.max(interval.end_line, block_line);
            }
         }
         for(String var: b.out){
            intervalinfo interval= func.interval_map.get(var);
            if(interval== null){
               interval= new intervalinfo(var, block_line, block_line);
               func.interval_map.put(var, interval);
            }
            else{
               interval.start_line= Math.min(interval.start_line, block_line);
               interval.end_line= Math.max(interval.end_line, block_line);
            }
         }
      }
   }

   public String get_free_register(functioninfo func){
      String temp= "-1";
      if(registers.size()>0){
         temp= registers.get(0);
         registers.remove(temp);
      }
      return temp;
   }

   public void add_reg(String reg, functioninfo func){
      if(reg.equals("-1")== false){
         registers.add(reg);
      }
   }

   public void set_nums(functioninfo func){
      func.stack_ptr+= Math.max(0,func.num_args -4);
      func.total_stack_size= func.stack_ptr;
      if(!func.function_name.equals("MAIN")){
         func.stack_ptr+= 8; //return address
      }
      if(func.call_check){
         func.stack_ptr+= 10; //saved registers
      }
   }

   public void reset_registers(){
      registers= new ArrayList<String>(Arrays.asList("s0","s1","s2","s3","s4","s5","s6","s7","t0","t1","t2","t3","t4","t5","t6","t7","t8","t9"));
   }

   public void expire(intervalinfo interval, functioninfo func){
      Collections.sort(func.activelist, Comparator.comparingInt(a -> a.end_line));
      ArrayList<intervalinfo> to_remove= new ArrayList<intervalinfo>();
      for(intervalinfo active: func.activelist){
         if(active.end_line < interval.start_line){
            add_reg(active.allocated_register, func);
            to_remove.add(active);
         }
      }
      for(intervalinfo rem: to_remove){
         func.activelist.remove(rem);
      }
   }

   public void spill(intervalinfo interval, functioninfo func){
      Integer active= func.activelist.size();
      intervalinfo spill_inteval= func.activelist.get(active -1);
      if(spill_inteval.end_line > interval.end_line){
         interval.allocated_register= spill_inteval.allocated_register;
         
         func.activelist.remove(spill_inteval);
         spill_inteval.allocated_register= "-1";
         func.activelist.add(interval);
         
         spill_inteval.stack_location= func.stack_ptr;
         func.stack_ptr++;
         func.stack_space.add(spill_inteval);
         Collections.sort(func.activelist, Comparator.comparingInt(a -> a.end_line));
      }
      else{
         interval.stack_location= func.stack_ptr;
         func.stack_ptr++;
         func.stack_space.add(interval);
      }
   }

   public void linear_scan(functioninfo func){
      for(Map.Entry<String, intervalinfo> entry: func.interval_map.entrySet()){
         func.intervallist.add(entry.getValue());
      }
      Collections.sort(func.intervallist, Comparator.comparingInt(a -> a.start_line));
      for(intervalinfo interval: func.intervallist){
         expire(interval, func);
         if(func.activelist.size() == free_reg){
            spill(interval, func);
         }
         else{
            interval.allocated_register= get_free_register(func);
            func.activelist.add(interval);
            Collections.sort(func.activelist, Comparator.comparingInt(a -> a.end_line));
         }
      }
   }

   public void allocation(){
      for(Map.Entry<String, functioninfo> entry: function_map.entrySet()){
         current_function= entry.getValue();
         calculate_jumps();
         blockinfo lastblock= current_function.blocks.get(current_function.blocks.size()-1);
         lastblock.next_block= -1;
         lastblock.jump_block= -1;
         blockinfo secondlast= current_function.blocks.get(current_function.blocks.size()-2);
         secondlast.jump_block= -1;
         secondlast.next_block= -1;

         calculate_inout();
         calculate_liverange(current_function);
         linear_scan(current_function);
         set_nums(current_function);
         reset_registers();
      }
   }

   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }


   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      current_function= new functioninfo("MAIN");
      function_map.put("MAIN", current_function);
      current_block= new blockinfo(line_counter++);
   current_function.blocks.add(current_block);

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      current_block= new blockinfo(line_counter++);
      current_function.blocks.add(current_block);

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      allocation();
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, (A)"label");
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String func_name= (n.f0).f0.tokenImage;
      current_block= new blockinfo(line_counter++);
      current_function= new functioninfo(func_name);
      current_function.num_args= (Integer)n.f2.accept(this, argu);
      function_map.put(func_name, current_function);
      current_function.blocks.add(current_block);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      current_block= new blockinfo(line_counter++);
      current_function.blocks.add(current_block);
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg= "use";
      n.f1.accept(this, (A)arg);
      label_status= true;
      n.f2.accept(this, argu);
      label_status= false;
      String label_name= (String)n.f2.f0.tokenImage;
      current_block.jump_block_name= current_function.function_name+"_"+label_name;
      
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String label_name= (String)n.f1.f0.tokenImage;
      current_block.next_block= -1;
      current_block.jump_block_name= current_function.function_name+"_"+label_name;
      label_status= true;
      n.f1.accept(this, argu);
      label_status= false;
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      String arg1= "use";
      n.f0.accept(this, argu);
      n.f1.accept(this, (A)arg1);
      n.f2.accept(this, argu);
      n.f3.accept(this, (A)arg1);
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      String arg1= "use";
      String arg2= "def";
      n.f0.accept(this, argu);
      n.f1.accept(this, (A)arg2);
      n.f2.accept(this, (A)arg1);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg1= "def";
      n.f1.accept(this, (A)arg1);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      current_block= new blockinfo(line_counter++);
      current_function.blocks.add(current_block);
      n.f1.accept(this, argu);
      current_block= new blockinfo(line_counter++);
      current_function.blocks.add(current_block);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      current_block= new blockinfo(line_counter++);
      current_function.blocks.add(current_block);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg1= "use";
      n.f1.accept(this, (A)arg1);
      n.f2.accept(this, argu);
      String arg2= "arg";
      argcounter= 0;
      n.f3.accept(this, (A)arg2);
      n.f4.accept(this, argu);
      current_function.max_callee_args= Math.max(current_function.max_callee_args, argcounter);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      String arg= "use";
      n.f0.accept(this, argu);
      n.f1.accept(this, (A)arg);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      String arg= "use";
      n.f0.accept(this, (A)arg);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;

      n.f0.accept(this, argu);
      Integer temp_num= Integer.parseInt(n.f1.f0.tokenImage);
      if(argu.equals("def")) {
         current_block.def.add("TEMP "+temp_num.toString());
      }
      else if(argu.equals("use")) {
         current_block.use.add("TEMP "+temp_num.toString());
      } 
      else if(argu.equals("arg")) {
         current_block.use.add("TEMP "+temp_num.toString());
         argcounter+= 1;
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      Integer literal_value= Integer.parseInt(n.f0.tokenImage);
      n.f0.accept(this, argu);
      return (R)literal_value;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String label_name= current_function.function_name+"_"+n.f0.tokenImage;
      if(argu==null)return _ret;
      if(argu.equals("label") && label_status== false) {
         current_function.label_map.put(label_name, line_counter);
         label_linemap.put(label_name, line_counter);
         current_block= new blockinfo(line_counter++);
         current_function.blocks.add(current_block);
      }
      return _ret;
   }

}
